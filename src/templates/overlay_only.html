{% extends "base.html" %}

{% block title %}Selection Protocol - Overlay{% endblock %}

{% block body_style %}
display: block;
{% endblock %}

{% block content %}
{% include "overlay.html" %}
{% endblock %}

{% block scripts %}
const canvas = document.getElementById('pieChart');
const ctx = canvas.getContext('2d');
let currentTime = 30;

// Countdown timer
setInterval(() => {
    currentTime--;
    if (currentTime < 0) {
        currentTime = 30; // Reset to 30 when it hits 0
    }
    updateTimerDisplay();
}, 1000);

function getTimerColor(seconds) {
    if (seconds >= 16) {
        return '#00ff88'; // Green
    } else if (seconds >= 1) {
        // Linear gradient from green → yellow → red
        // Convert to HSL for smooth interpolation
        // Green: hsl(158, 100%, 50%)
        // Red: hsl(0, 100%, 50%)
        const progress = (15 - seconds) / 14; // 0 to 1 as time decreases from 15 to 1
        const hue = 158 - (158 * progress); // 158 → 0
        return `hsl(${hue}, 100%, 50%)`;
    } else {
        return '#ff0000'; // Bright red at 0
    }
}

function updateTimerDisplay() {
    const timerEl = document.getElementById('time-remaining');
    timerEl.textContent = currentTime + 's';
    timerEl.style.color = getTimerColor(currentTime);
    timerEl.style.textShadow = `0 0 20px ${getTimerColor(currentTime)}80`;
}

function getBorderColor(kVotes, lVotes, xVotes) {
    const total = kVotes + lVotes + xVotes;
    if (total === 0) {
        return '#00ff88'; // Green when no votes
    }

    // Find which vote is winning
    const max = Math.max(kVotes, lVotes, xVotes);

    // Check for tie
    const winners = [
        kVotes === max ? 'k' : null,
        lVotes === max ? 'l' : null,
        xVotes === max ? 'x' : null
    ].filter(v => v !== null);

    if (winners.length > 1) {
        return '#00ff88'; // Green when tied
    }

    // Color based on winner
    if (kVotes === max) return '#ff6666'; // Red for K
    if (lVotes === max) return '#6666ff'; // Blue for L
    if (xVotes === max) return '#00ff88'; // Green for X
}

function updateCanvasBorder(kVotes, lVotes, xVotes) {
    canvas.style.borderColor = getBorderColor(kVotes, lVotes, xVotes);
}

function drawPieChart(kVotes, lVotes, xVotes) {
    const total = kVotes + lVotes + xVotes;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = 60;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (total === 0) {
        // Draw empty circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fillStyle = '#333333';
        ctx.fill();
        return;
    }

    // Calculate angles (clockwise from 12 o'clock: L, X, K)
    const lAngle = (lVotes / total) * 2 * Math.PI;
    const xAngle = (xVotes / total) * 2 * Math.PI;
    const kAngle = (kVotes / total) * 2 * Math.PI;

    let currentAngle = -Math.PI / 2; // Start at 12 o'clock

    // Draw L slice (blue)
    if (lVotes > 0) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + lAngle);
        ctx.closePath();
        ctx.fillStyle = '#6666ff';
        ctx.fill();
        currentAngle += lAngle;
    }

    // Draw X slice (green)
    if (xVotes > 0) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + xAngle);
        ctx.closePath();
        ctx.fillStyle = '#00ff88';
        ctx.fill();
        currentAngle += xAngle;
    }

    // Draw K slice (red)
    if (kVotes > 0) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + kAngle);
        ctx.closePath();
        ctx.fillStyle = '#ff6666';
        ctx.fill();
    }

    // Update border color based on votes
    updateCanvasBorder(kVotes, lVotes, xVotes);
}

socket.on('connect', function() {
    console.log('Connected to overlay server');
});

let lastKVotes = 0;
let lastLVotes = 0;
let lastXVotes = 0;

socket.on('vote_update', function(data) {
    console.log('Vote update:', data);

    // Update vote counts with animation
    const kCountEl = document.getElementById('k-count');
    const lCountEl = document.getElementById('l-count');
    const xCountEl = document.getElementById('x-count');

    if (data.k_votes !== lastKVotes) {
        kCountEl.classList.remove('animate');
        void kCountEl.offsetWidth; // Force reflow
        kCountEl.classList.add('animate');
        lastKVotes = data.k_votes;
    }

    if (data.l_votes !== lastLVotes) {
        lCountEl.classList.remove('animate');
        void lCountEl.offsetWidth; // Force reflow
        lCountEl.classList.add('animate');
        lastLVotes = data.l_votes;
    }

    if (data.x_votes !== lastXVotes) {
        xCountEl.classList.remove('animate');
        void xCountEl.offsetWidth; // Force reflow
        xCountEl.classList.add('animate');
        lastXVotes = data.x_votes;
    }

    kCountEl.textContent = data.k_votes;
    lCountEl.textContent = data.l_votes;
    xCountEl.textContent = data.x_votes;

    // Calculate percentages
    const total = data.k_votes + data.l_votes + data.x_votes;
    let kPercent = 33;
    let lPercent = 33;
    let xPercent = 33;

    if (total > 0) {
        kPercent = (data.k_votes / total) * 100;
        lPercent = (data.l_votes / total) * 100;
        xPercent = (data.x_votes / total) * 100;
    }

    // Update pie chart
    drawPieChart(data.k_votes, data.l_votes, data.x_votes);

    // Update timer
    document.getElementById('time-remaining').textContent = data.time_remaining + 's';

    // Update status
    const statusEl = document.getElementById('status');
    if (data.voting_active) {
        statusEl.textContent = 'Chat decides fate (NOT YET LIVE). Features coming: KILL, REPRODUCE, change target, zoom, change/show/hide info overlay panels';
    } else {
        statusEl.textContent = 'Waiting for next vote...';
    }
});

// Initial draw
drawPieChart(0, 0, 0);
updateTimerDisplay();
{% endblock %}
