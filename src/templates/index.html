{% extends "base.html" %}

{% block title %}Selection Protocol - Overlay + Admin{% endblock %}

{% block content %}
{% include "admin_panel.html" %}
{% include "overlay.html" %}
{% endblock %}

{% block scripts %}
const canvas = document.getElementById('pieChart');
const ctx = canvas.getContext('2d');
let currentTime = 30;

// Countdown timer
setInterval(() => {
    currentTime--;
    if (currentTime < 0) {
        currentTime = 30; // Reset to 30 when it hits 0
    }
    updateTimerDisplay();
}, 1000);

function getTimerColor(seconds) {
    if (seconds >= 16) {
        return '#00ff88'; // Green
    } else if (seconds >= 1) {
        // Linear gradient from green → yellow → red
        // Convert to HSL for smooth interpolation
        // Green: hsl(158, 100%, 50%)
        // Red: hsl(0, 100%, 50%)
        const progress = (15 - seconds) / 14; // 0 to 1 as time decreases from 15 to 1
        const hue = 158 - (158 * progress); // 158 → 0
        return `hsl(${hue}, 100%, 50%)`;
    } else {
        return '#ff0000'; // Bright red at 0
    }
}

function updateTimerDisplay() {
    const timerEl = document.getElementById('time-remaining');
    timerEl.textContent = currentTime + 's';
    timerEl.style.color = getTimerColor(currentTime);
    timerEl.style.textShadow = `0 0 20px ${getTimerColor(currentTime)}80`;
}

function getBorderColor(kVotes, lVotes, xVotes) {
    const total = kVotes + lVotes + xVotes;
    if (total === 0) {
        return '#00ff88'; // Green when no votes
    }

    // Find which vote is winning
    const max = Math.max(kVotes, lVotes, xVotes);

    // Check for tie
    const winners = [
        kVotes === max ? 'k' : null,
        lVotes === max ? 'l' : null,
        xVotes === max ? 'x' : null
    ].filter(v => v !== null);

    if (winners.length > 1) {
        return '#00ff88'; // Green when tied
    }

    // Color based on winner
    if (kVotes === max) return '#ff6666'; // Red for K
    if (lVotes === max) return '#6666ff'; // Blue for L
    if (xVotes === max) return '#00ff88'; // Green for X
}

function updateCanvasBorder(kVotes, lVotes, xVotes) {
    canvas.style.borderColor = getBorderColor(kVotes, lVotes, xVotes);
}

function drawPieChart(kVotes, lVotes, xVotes) {
    const total = kVotes + lVotes + xVotes;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = 60;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (total === 0) {
        // Draw empty circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fillStyle = '#333333';
        ctx.fill();
        return;
    }

    // Calculate angles (clockwise from 12 o'clock: L, X, K)
    const lAngle = (lVotes / total) * 2 * Math.PI;
    const xAngle = (xVotes / total) * 2 * Math.PI;
    const kAngle = (kVotes / total) * 2 * Math.PI;

    let currentAngle = -Math.PI / 2; // Start at 12 o'clock

    // Draw L slice (blue)
    if (lVotes > 0) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + lAngle);
        ctx.closePath();
        ctx.fillStyle = '#6666ff';
        ctx.fill();
        currentAngle += lAngle;
    }

    // Draw X slice (green)
    if (xVotes > 0) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + xAngle);
        ctx.closePath();
        ctx.fillStyle = '#00ff88';
        ctx.fill();
        currentAngle += xAngle;
    }

    // Draw K slice (red)
    if (kVotes > 0) {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + kAngle);
        ctx.closePath();
        ctx.fillStyle = '#ff6666';
        ctx.fill();
    }

    // Update border color based on votes
    updateCanvasBorder(kVotes, lVotes, xVotes);
}

socket.on('connect', function() {
    console.log('Connected to overlay server');
});

let lastKVotes = 0;
let lastLVotes = 0;
let lastXVotes = 0;

socket.on('vote_update', function(data) {
    console.log('Vote update:', data);

    // Update vote counts with animation
    const kCountEl = document.getElementById('k-count');
    const lCountEl = document.getElementById('l-count');
    const xCountEl = document.getElementById('x-count');

    if (data.k_votes !== lastKVotes) {
        kCountEl.classList.remove('animate');
        void kCountEl.offsetWidth; // Force reflow
        kCountEl.classList.add('animate');
        lastKVotes = data.k_votes;
    }

    if (data.l_votes !== lastLVotes) {
        lCountEl.classList.remove('animate');
        void lCountEl.offsetWidth; // Force reflow
        lCountEl.classList.add('animate');
        lastLVotes = data.l_votes;
    }

    if (data.x_votes !== lastXVotes) {
        xCountEl.classList.remove('animate');
        void xCountEl.offsetWidth; // Force reflow
        xCountEl.classList.add('animate');
        lastXVotes = data.x_votes;
    }

    kCountEl.textContent = data.k_votes;
    lCountEl.textContent = data.l_votes;
    xCountEl.textContent = data.x_votes;

    // Update first-L claimant
    const claimantEl = document.getElementById('l-claimant');
    if (data.first_l_claimant) {
        claimantEl.textContent = data.first_l_claimant;
    } else {
        claimantEl.textContent = '';
    }

    // Calculate percentages
    const total = data.k_votes + data.l_votes + data.x_votes;
    let kPercent = 33;
    let lPercent = 33;
    let xPercent = 33;

    if (total > 0) {
        kPercent = (data.k_votes / total) * 100;
        lPercent = (data.l_votes / total) * 100;
        xPercent = (data.x_votes / total) * 100;
    }

    // Update pie chart
    drawPieChart(data.k_votes, data.l_votes, data.x_votes);

    // Update timer
    document.getElementById('time-remaining').textContent = data.time_remaining + 's';

    // Update status
    const statusEl = document.getElementById('status');
    if (data.voting_active) {
        statusEl.textContent = 'Chat decides fate (NOT YET LIVE). Features coming: KILL, REPRODUCE, change target, zoom, change/show/hide info overlay panels';
    } else {
        statusEl.textContent = 'Waiting for next vote...';
    }
});

// Initial draw
drawPieChart(0, 0, 0);
updateTimerDisplay();

// Cooldown tracking
let cooldownIntervals = {};

// Timer Controls
function adminPauseTimer() {
    socket.emit('admin_pause_timer');
}

function adminResumeTimer() {
    socket.emit('admin_resume_timer');
}

function adminResetTimer() {
    socket.emit('admin_reset_timer', {duration: 30});
}

// Game Keypress Functions with Cooldown Check
function sendKeypress(key, cooldownGroup) {
    socket.emit('admin_send_keypress', {key: key, cooldown_group: cooldownGroup});
}

// Cooldown UI Update
function updateCooldownUI(cooldownState) {
    // Update primary cooldown (Kill, Lay)
    const primaryRemaining = cooldownState.primary.remaining;
    const primaryBtn = document.getElementById('btn-kill');
    const layBtn = document.getElementById('btn-lay');
    const primaryStatus = document.getElementById('primary-cooldown');

    if (cooldownState.primary.active) {
        primaryBtn.disabled = true;
        layBtn.disabled = true;
        document.getElementById('cd-kill').textContent = `CD: ${primaryRemaining}s`;
        document.getElementById('cd-kill').style.display = 'flex';
        document.getElementById('cd-lay').textContent = `CD: ${primaryRemaining}s`;
        document.getElementById('cd-lay').style.display = 'flex';
        primaryStatus.textContent = `${primaryRemaining}s`;
    } else {
        primaryBtn.disabled = false;
        layBtn.disabled = false;
        document.getElementById('cd-kill').style.display = 'none';
        document.getElementById('cd-lay').style.display = 'none';
        primaryStatus.textContent = 'Ready';
    }

    // Update extend cooldown
    const extendBtn = document.getElementById('btn-extend');
    if (cooldownState.extend.active) {
        extendBtn.disabled = true;
        document.getElementById('cd-extend').textContent = `CD: ${cooldownState.extend.remaining}s`;
        document.getElementById('cd-extend').style.display = 'flex';
    } else {
        extendBtn.disabled = false;
        document.getElementById('cd-extend').style.display = 'none';
    }

    // Update camera cooldown
    const camGenBtn = document.getElementById('btn-cam-gen');
    const camOldBtn = document.getElementById('btn-cam-old');
    const camRandBtn = document.getElementById('btn-cam-rand');
    const cameraActive = cooldownState.camera.active;

    camGenBtn.disabled = cameraActive;
    camOldBtn.disabled = cameraActive;
    camRandBtn.disabled = cameraActive;

    // Update zoom cooldowns
    const zoomInBtn = document.getElementById('btn-zoom-in');
    const zoomOutBtn = document.getElementById('btn-zoom-out');

    if (cooldownState.zoom_in.active) {
        zoomInBtn.disabled = true;
        document.getElementById('cd-zoom-in').textContent = `CD: ${cooldownState.zoom_in.remaining}s`;
        document.getElementById('cd-zoom-in').style.display = 'flex';
    } else {
        zoomInBtn.disabled = false;
        document.getElementById('cd-zoom-in').style.display = 'none';
    }

    if (cooldownState.zoom_out.active) {
        zoomOutBtn.disabled = true;
        document.getElementById('cd-zoom-out').textContent = `CD: ${cooldownState.zoom_out.remaining}s`;
        document.getElementById('cd-zoom-out').style.display = 'flex';
    } else {
        zoomOutBtn.disabled = false;
        document.getElementById('cd-zoom-out').style.display = 'none';
    }
}

// Admin state update handler
socket.on('admin_state_update', function(data) {
    console.log('Admin state update:', data);

    // Update admin panel displays
    if (data.last_action_time) {
        document.getElementById('last-action-display').textContent =
            `${data.last_action} @ ${data.last_action_time}`;
    }
    if (data.camera_mode) {
        document.getElementById('camera-mode').textContent = data.camera_mode;
    }
    if (data.connected_clients !== undefined) {
        document.getElementById('client-count').textContent = data.connected_clients;
    }
});

// Cooldown update handler
socket.on('cooldown_update', function(cooldownState) {
    console.log('Cooldown update:', cooldownState);
    updateCooldownUI(cooldownState);
});

// Keypress result handler
socket.on('keypress_result', function(data) {
    console.log('Keypress result:', data);
    if (data.success) {
        console.log(`Keypress ${data.key} succeeded`);
    } else {
        console.error('Keypress failed:', data.error);
    }
});

// Request cooldown updates every second
setInterval(() => {
    socket.emit('get_cooldown_state');
}, 1000);
{% endblock %}
